<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading Animation</title>
</head>
<body>
    
</body>
</html>
<style>
body {
    background: #000000;  
}

#container {
    position: absolute;
    width: 200px;
    height: 200px;
    margin: auto;
    transform: rotate(45deg);
    top: 0; bottom: 0; left: 0; right: 0;
}
</style>

<canvas id="container" width="200" height="200"></canvas>

<script>
var points = [],
    velocity2 = 5, // velocity squared
    canvas = document.getElementById('container'),
    context = canvas.getContext('2d'),
    radius = 5,
    boundaryX = 75, // Initial value updated
    boundaryY = 75, // Initial value updated
    numberOfPoints = 4;

let nodeInterval; // Added for managing the interval
let boundaryInterval; // Added for managing boundary expansion

// New assignBuddies function for network-like connections
function assignBuddies() {
    if (points.length === 0) return;

    for (let i = 0; i < points.length; i++) {
        let point = points[i];
        point.buddies = []; // Clear/initialize buddies array

        if (points.length === 1) continue; // No buddies if only one point

        let numTargetConnections;
        const rand = Math.random();
        // Determine target number of connections (ensure it's possible given points.length)
        if (rand < 0.05 && points.length -1 >= 4) { // ~5% chance for 4 connections
            numTargetConnections = 4;
        } else if (rand < 0.20 && points.length -1 >= 3) { // ~15% chance for 3 connections (cumulative ~5%+15% = ~20%)
            numTargetConnections = 3;
        } else if (points.length -1 >= 2) { // ~80% chance for 2 connections (remaining)
            numTargetConnections = 2;
        } else { // Default to 1 connection if only 2 points total
            numTargetConnections = 1;
        }
        
        // Ensure target connections is not more than possible and at least 1 if multiple points
        numTargetConnections = Math.min(numTargetConnections, points.length - 1);
        numTargetConnections = Math.max(1, numTargetConnections);

        // Add the next point in the ring as a guaranteed first buddy for basic connectivity
        let nextPointIndex = (i + 1) % points.length;
        if (points[nextPointIndex] !== point) { // Check avoids adding self if only one point (already handled by length check)
             point.buddies.push(points[nextPointIndex]);
        }

        // Add more random distinct buddies
        let attempts = 0;
        const maxAttempts = points.length * 3; // Safety break, increased attempts slightly

        while (point.buddies.length < numTargetConnections && attempts < maxAttempts) {
            let randomIndex = Math.floor(Math.random() * points.length);
            let potentialBuddy = points[randomIndex];

            if (potentialBuddy !== point && !point.buddies.includes(potentialBuddy)) {
                point.buddies.push(potentialBuddy);
            }
            attempts++;
        }
    }
}

// Added function to periodically add nodes
function addNodesPeriodically() {
    if (points.length >= 20) {
        clearInterval(nodeInterval);
        return;
    }

    const pointsStillNeeded = 20 - points.length;
    const pointsToAddThisTurn = Math.min(2, pointsStillNeeded);

    for (let i = 0; i < pointsToAddThisTurn; i++) {
        createPoint(); 
    }

    if (pointsToAddThisTurn > 0) { 
        assignBuddies();
    }

    if (points.length >= 20) {
        clearInterval(nodeInterval);
    }
}

// Added function to periodically expand boundaries
function expandBoundariesPeriodically() {
    let changed = false;
    if (boundaryX < 200) {
        boundaryX = Math.min(200, boundaryX + 15);
        changed = true;
    }
    if (boundaryY < 200) {
        boundaryY = Math.min(200, boundaryY + 15);
        changed = true;
    }

    if (boundaryX >= 200 && boundaryY >= 200) {
        clearInterval(boundaryInterval);
    }
}

init();

function init() {
    // create initial points (respects numberOfPoints which is 4 as per current file state)
    for (var i = 0; i < numberOfPoints; i++) {
        createPoint();
    }
    assignBuddies(); // Assign buddies for initial points
    
    // animate
    animate();

    // Start adding more nodes if not already at max
    if (points.length < 20) {
        nodeInterval = setInterval(addNodesPeriodically, 1000);
    }

    // Start expanding boundaries if not already at max
    if (boundaryX < 200 || boundaryY < 200) {
        boundaryInterval = setInterval(expandBoundariesPeriodically, 1000);
    }
}

function createPoint() {
    var point = {}, vx2, vy2;
    point.x = Math.random()*boundaryX;
    point.y = Math.random()*boundaryY;
    // random vx 
    point.vx = (Math.floor(Math.random())*2-1)*Math.random();
    vx2 = Math.pow(point.vx, 2);
    // vy^2 = velocity^2 - vx^2
    vy2 = velocity2 - vx2;
    point.vy = Math.sqrt(vy2) * (Math.random()*2-1);
    point.buddies = []; // Initialize buddies array
    points.push(point);
}

function resetVelocity(point, axis, dir) {
    var vx, vy;
    if(axis == 'x') {
        point.vx = dir*Math.random();  
        vx2 = Math.pow(point.vx, 2);
        // vy^2 = velocity^2 - vx^2
        vy2 = velocity2 - vx2;
        point.vy = Math.sqrt(vy2) * (Math.random()*2-1);
    } else {
        point.vy = dir*Math.random();  
        vy2 = Math.pow(point.vy, 2);
        // vy^2 = velocity^2 - vx^2
        vx2 = velocity2 - vy2;
        point.vx = Math.sqrt(vx2) * (Math.random()*2-1);
    }
}

function drawCircle(x, y) {
    context.beginPath();
    context.arc(x, y, radius, 0, 2 * Math.PI, false);
    context.fillStyle = '#69b3a2';
    context.fill();  
}

function drawLine(x1, y1, x2, y2) {
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.strokeStyle = '#ffffff';
    context.stroke();
}  

function draw() {
    for(var i =0, l=points.length; i<l; i++) {
        // circles
        var point = points[i];
        point.x += point.vx;
        point.y += point.vy;
        drawCircle(point.x, point.y);
        // lines
        if (point.buddies) {
            for (let k = 0; k < point.buddies.length; k++) {
                let buddy = point.buddies[k];
                if (buddy) { // Ensure buddy is defined
                     drawLine(point.x, point.y, buddy.x, buddy.y);
                }
            }
        }
        // check for edge
        if(point.x < 0+radius) {
            resetVelocity(point, 'x', 1);
        } else if(point.x > boundaryX-radius) {
            resetVelocity(point, 'x', -1);
        } else if(point.y < 0+radius) {
            resetVelocity(point, 'y', 1);
        } else if(point.y > boundaryY-radius) {
            resetVelocity(point, 'y', -1);
        } 
    }
}

function animate() {
    context.clearRect ( 0 , 0 , 200 , 200 );
    draw();
    requestAnimationFrame(animate);
}
</script>
